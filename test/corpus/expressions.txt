======
Number
======

#eval 2

---

(module (interactive (number)))

=====
Float
=====

#eval 23.279
#eval 2.

---

(module (interactive (float)) (interactive (float)))

=====
Range
=====

#check [0:foo 3:1]

---

(module
  (interactive
    (range
      start: (number)
      stop:
        (apply
          lhs: (identifier)
          argument: (number))
      step: (number))))

=============
Range No Step
=============

#check [0:10]

---

(module
  (interactive
    (range
      start: (number)
      stop: (number))))

=============
Range No Start
=============

#check [:3]

---

(module
  (interactive
    (range
      stop: (number))))

====
List
====

#check [1, 2, 3]
#check []

---

(module
  (interactive (list (number) (number) (number)))
  (interactive (list)))

=========
Array Ref
=========

#check foo[bar 3]

---

(module
  (interactive
    (subarray
      term: (identifier)
      value:
        (apply
          lhs: (identifier)
          argument: (number)))))

========
Subarray
========

#check foo[0:bar 3]

---

(module
  (interactive
    (subarray
      term: (identifier)
      start: (number)
      stop:
        (apply
          lhs: (identifier)
          argument: (number)))))

================
Subarray No Stop
================

#check foo[0:]

---

(module
  (interactive
    (subarray
      term: (identifier)
      start: (number))))

=================
Subarray No Start
=================

#check foo[:3]

---

(module
  (interactive
    (subarray
      term: (identifier)
      stop: (number))))

======================
Subarray of Expression
======================

#check (foo 37)[:3]

---

(module
  (interactive
    (subarray
      term:
        (parenthesized
          (apply
            lhs: (identifier)
            argument: (number)))
      stop: (number))))

===========================
Subarray Does Not Have Step
===========================

#check foo[1:2:3]

---

(module
  (interactive
    (subarray
      (identifier) (number) (ERROR (number)) (number))))

===========================
Subarray Does Not Have Copy
===========================

#check foo[:]

---

(module
  (interactive
    (subarray (identifier) (identifier (MISSING _identifier)))))

==================
Subarray vs. Range
==================

#check foo [1:2]

---

(module
  (interactive
    (apply
      lhs: (identifier)
      argument:
        (range
          start: (number)
          stop: (number)))))

=====
Array
=====

#check #[1, 2, 3]
#check #[]

---

(module
  (interactive (array (number) (number) (number)))
  (interactive (array)))

=====================
Inductive Constructor
=====================

example : Foo := ‚ü®1, 2, 3‚ü©
example : Foo := ‚ü®1‚ü©
example : Foo := ‚ü®‚ü©

---

(module
  (declaration (example (identifier) (anonymousConstructor (number) (number) (number))))
  (declaration (example (identifier) (anonymousConstructor (number))))
  (declaration (example (identifier) (anonymousConstructor))))

=============================
Invalid Inductive Constructor
=============================

example : Foo := ‚ü®,‚ü©
example : Foo := ‚ü®, 1‚ü©
example : Foo := ‚ü®, 2,‚ü©

---

(module
  (declaration (example (identifier) (anonymousConstructor (ERROR))))
  (declaration (example (identifier) (anonymousConstructor (ERROR) (number))))
  (declaration (example (identifier) (anonymousConstructor (ERROR) (number) (ERROR)))))

===========
Identifiers
===========

#eval foo‚ÇÅ
#eval x'
#eval foo!
#eval foo?
#eval ùíû

---

(module
  (interactive (identifier))
  (interactive (identifier))
  (interactive (identifier))
  (interactive (identifier))
  (interactive (identifier)))

===============
Non-Identifiers
===============

#eval ‚ÇÅfoo
#eval 'x
#eval !foo
#eval foo.

---

(module
  (interactive (ERROR (UNEXPECTED 8321)) (identifier))
  (interactive (char (MISSING "'")))
  (interactive (unaryExpression (identifier)))
  (interactive (identifier)) (ERROR))

=======
Product
=======

#check (10, "foo", 30, 40)

---

(module
  (interactive
    (parenthesized (number) (tupleTail (string) (number) (number)))))

=============
Function Type
=============

#check foo ‚Üí bar
#check foo ‚Üí bar ‚Üí baz

---

(module
  (interactive (arrow (identifier) (identifier)))
  (interactive (arrow (identifier) (arrow (identifier) (identifier)))))

============
Product Type
============

#check A √ó B
#check A √ó B √ó C
#check (A √ó B) √ó C

---

(module
  (interactive (product (identifier) (identifier)))
  (interactive (product (identifier) (product (identifier) (identifier))))
  (interactive
    (product
      (parenthesized (product (identifier) (identifier))) (identifier))))

=======================
Product Type Precedence
=======================

#check f 3 √ó C

---

; FIXME: This is wrong (backwards)... but apply's precedence needs fixing

(module
  (interactive (apply (identifier) (product (number) (identifier)))))

============
If/Then/Else
============

#eval if true then "foo" else "bar"

---

(module (interactive (ite (true) (string) (string))))

=============
If Needs Else
=============

#eval if true then "foo"

---

(module (ERROR (true) (string)))

===================
Nested If/Then/Else
===================

#eval if true then if false then "foo" else "bar" else "baz"

---

(module
  (interactive
    (ite (true)
      (ite (false) (string) (string))
      (string))))

==========
- Negation
==========

#eval -2
#eval -2.0
#eval -foo
#eval - -2
#eval - -foo
#eval -(2 + 2)
#eval - -(2 + 2)

---

(module
  (interactive (neg (number)))
  (interactive (neg (float)))
  (interactive (neg (identifier)))
  (interactive (neg (neg (number))))
  (interactive (neg (neg (identifier))))
  (interactive
    (neg
      (parenthesized (binaryExpression (number) (number)))))
  (interactive
    (neg
      (neg
        (parenthesized (binaryExpression (number) (number)))))))

=======================
- Negation But Comments
=======================

#eval --2
#eval --foo

---

(module (ERROR (comment) (comment)))

==========
! Negation
==========

#eval !true
#eval !!!true
#eval !foo

---

(module
  (interactive (unaryExpression (true)))
  (interactive
    (unaryExpression (unaryExpression (unaryExpression (true)))))
  (interactive (unaryExpression (identifier))))

==========
¬¨ Negation
==========

#eval ¬¨true
#eval ¬¨¬¨¬¨true
#eval ¬¨foo

---

(module
  (interactive (unaryExpression (true)))
  (interactive
    (unaryExpression (unaryExpression (unaryExpression (true)))))
  (interactive (unaryExpression (identifier))))

==============
Pipe Operators
==============

#eval times2 <| add1 <| 100
#eval 100 |> add1 |> times2

---

(module
  (interactive
    (binaryExpression
      (binaryExpression (number) (identifier))
      (identifier)))
  (interactive
    (binaryExpression
      (binaryExpression (identifier) (apply (identifier) (identifier)))
      (apply (identifier) (number))))

==================
Binary Expressions
==================

---

#eval 2 + 3
#eval 2 - 3
#eval 2 * 3
#eval 2 / 3
#eval 2 % 3
#eval 2 ^ 3
#eval 2 = 3
#eval 2 ‚â† 3
#eval true ‚àß true
#eval true ‚à® true
#eval true ‚Üî true
#eval true && true
#eval true || true
#eval "foo" ++ "bar"
#eval [] :: [["foo"]]
#eval foo |>.map bar |>.baz.quux 7
#eval foo <|> bar
#eval 'B' == 'B' || 'B' == 'C'
#check f ‚àò g ‚àò h

---
(module
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (number) (number)))
  (interactive (binaryExpression (true) (true)))
  (interactive (binaryExpression (true) (true)))
  (interactive (binaryExpression (true) (true)))
  (interactive (binaryExpression (true) (true)))
  (interactive (binaryExpression (true) (true)))
  (interactive (binaryExpression (string) (string)))
  (interactive (binaryExpression (list) (list (list (string)))))
  (interactive
    (binaryExpression
      (identifier)
      (binaryExpression (identifier) (number))))
  (interactive (binaryExpression (identifier) (identifier)))
  (interactive
    (binaryExpression
      (binaryExpression (char) (char))
      (binaryExpression (char) (char))))
  (interactive
    (binaryExpression
      (identifier)
      (binaryExpression (identifier) (identifier)))))

==========
Precedence
==========

#eval 4 == 4 - 0
#eval 4 == 3 + 1
#eval 4 == 4 * 1
#eval 4 == 4 / 1
#eval 4 == 4 % 5
example : 4 = 4 - 0 := rfl
example : 4 = 3 + 1 := rfl
example : 4 = 4 * 1 := rfl
example : 4 = 4 / 1 := rfl
example : 4 = 4 % 5 := rfl
#eval false && false || true
#eval true || false && false
#eval 2 ^ 3 * 7 + 2
#eval -2.0 ^ 3 * 7

---

(module
  (interactive
    (binaryExpression (number) (binaryExpression (number) (number))))
  (interactive
    (binaryExpression (number) (binaryExpression (number) (number))))
  (interactive
    (binaryExpression (number) (binaryExpression (number) (number))))
  (interactive
    (binaryExpression (number) (binaryExpression (number) (number))))
  (interactive
    (binaryExpression (number) (binaryExpression (number) (number))))
  (declaration
    (example
      type:
        (binaryExpression (number) (binaryExpression (number) (number)))
      body:
        (identifier)))
  (declaration
    (example
      type:
        (binaryExpression (number) (binaryExpression (number) (number)))
      body:
        (identifier)))
  (declaration
    (example
      type:
        (binaryExpression (number) (binaryExpression (number) (number)))
      body:
        (identifier)))
  (declaration
    (example
      type:
        (binaryExpression (number) (binaryExpression (number) (number)))
      body:
        (identifier)))
  (declaration
    (example
      type:
        (binaryExpression (number) (binaryExpression (number) (number)))
      body:
        (identifier)))
  (interactive
    (binaryExpression (binaryExpression (false) (false)) (true)))
  (interactive
    (binaryExpression (true) (binaryExpression (false) (false))))
  (interactive
    (binaryExpression
      (binaryExpression
        (binaryExpression (number) (number))
        (number))
      (number)))
  (interactive
    (binaryExpression
      (binaryExpression (neg (float)) (number))
      (number))))

==========
Comparison
==========

#check 2 < 3
#check 2 ‚â§ 3
#check 2 <= 3
#check 2 > 3
#check 2 ‚â• 3
#check 2 >= 3

---

(module
  (interactive (comparison (number) (number)))
  (interactive (comparison (number) (number)))
  (interactive (comparison (number) (number)))
  (interactive (comparison (number) (number)))
  (interactive (comparison (number) (number)))
  (interactive (comparison (number) (number))))

=====================
Comparison Precedence
=====================

example : id 2 < 3 = true := rfl
example : 2 > id 3 = false := rfl
example : id 2 ‚â§ 3 = true := rfl
example : 2 ‚â• id 3 = false := rfl

---

(module
  (declaration
    (example
      (binaryExpression
        (comparison
          (apply (identifier) (number))
          (number))
        (true))
      (identifier)))
  (declaration
    (example
      (binaryExpression
        (comparison
          (number)
          (apply (identifier) (number)))
        (false))
      (identifier)))
  (declaration
    (example
      (binaryExpression
        (comparison
          (apply (identifier) (number))
          (number))
        (true))
      (identifier)))
  (declaration
    (example
      (binaryExpression
        (comparison
          (number)
          (apply (identifier) (number)))
        (false))
      (identifier))))

===========================
Multiple Function Arguments
===========================

#check foo 2 3 4

---

(module
  (interactive
    (apply (identifier) (number) (number) (number))))

===============
Named Arguments
===============

#check foo (bar := 3)

---

(module
  (interactive
    (apply (identifier) (namedArgument (identifier) (number)))))

=====================
Mixed Named Arguments
=====================

#check foo 1 (bar := 3) 2 (baz := 4)

---

(module
  (interactive
    (apply (identifier)
        (number)
        (namedArgument (identifier) (number))
        (number)
        (namedArgument (identifier) (number)))))

============
Field Access
============

#check FooBar.foo
#check foo.12

---

(module
  (interactive (identifier))
  (interactive
    (proj
      term: (identifier)
      name: (number))))

===================
Nested Field Access
===================

#check Foo.bar.baz.quux

---

(module (interactive (identifier)))

=======================
Expression Field Access
=======================

#check (Foo.bar baz).baz

---

(module
  (interactive
    (proj
      (parenthesized (apply (identifier) (identifier)))
      (identifier))))

=====
Match
=====

def foo (d : Bar) : Baz :=
  match d with
  | quux => 1

---

(module
  (declaration
    (def
      name: (identifier)
      (binders
        (explicitBinder
          name: (identifier)
          type: (identifier)))
      type: (identifier)
      body:
        (match
          value: (identifier)
          patterns:
            (matchAlt
              lhs: (identifier)
              (number))))))

==============
Match Multiple
==============

def foo (a b c : Nat) :=
  match a, b, c with
  | _, _, _ => true

---

(module
  (declaration
    (def
      name: (identifier)
      (binders
        (explicitBinder
          name: (identifier)
          name: (identifier)
          name: (identifier)
          type: (identifier)))
      body:
        (match
          value: (identifier)
          value: (identifier)
          value: (identifier)
          patterns:
            (matchAlt
              lhs: (hole)
              lhs: (hole)
              lhs: (hole)
              (true))))))

=========================
Match Multiple With Apply
=========================

#eval match 0 with
| 0 => id 2
| _ => id 4

---

(module
  (interactive
    (match (number)
      (matchAlt (number) (apply (identifier) (number)))
      (matchAlt (hole) (apply (identifier) (number))))))

================
Match Expression
================

#eval match Nat.succ 3 with
  | _ => true

---

(module
  (interactive
    (match
      value:
        (apply
          name: (identifier)
          argument: (number))
      patterns:
        (matchAlt
          lhs: (hole)
          (true)))))

=============
$ Application
=============

#eval foo bar (baz (1 + 1))
#eval foo bar $ baz (1 + 1)
#eval foo bar $ baz $ 1 + 1

---

(module
  (interactive
    (apply (identifier) (identifier)
      (parenthesized
        (apply (identifier)
          (parenthesized (binaryExpression (number) (number)))))))
  (interactive
    (apply
      (apply (identifier) (identifier))
        (apply (identifier)
          (parenthesized (binaryExpression (number) (number))))))
  (interactive
    (apply
      (apply (identifier) (identifier))
        (apply (identifier) (binaryExpression (number) (number))))))

==================
Anonymous Function
==================

#check fun x => x + 2

---

(module
  (interactive
    (fun
      (parameters (identifier))
      (binaryExpression (identifier) (number)))))

=============================
Anonymous Function via Lambda
=============================

#check Œª x => x

---

(module
  (interactive
    (fun (parameters (identifier)) (identifier))))

==========================================
Anonymous Function With Destructuring Bind
==========================================

#check Œª ‚ü®a‚ü© v ‚ü®w, x, y‚ü© z => a

---

(module
  (interactive
    (fun
      (parameters
        (anonymousConstructor (identifier))
        name: (identifier)
        (anonymousConstructor (identifier) (identifier) (identifier))
        name: (identifier))
      (identifier))))

==============================
Anonymous Function Application
==============================

#eval (fun x => x + 2) 10

---

(module
  (interactive
    (apply
      (parenthesized
        (fun
          (parameters (identifier))
          (binaryExpression (identifier) (number))))
      (number))))

=================================================
Anonymous Function Match With Additional Argument
=================================================

#eval foo 0 fun
  | 0 => 0
  | n => 1
  37

---

(module
  (interactive
    (apply
      lhs: (identifier)
      argument: (number)
      argument:
        (fun
          lhs: (number)
          (number)
          lhs: (identifier)
          (number))
      argument:
        (number))))

==========================
Sugared Anonymous Function
==========================

#check (¬∑ + 2)
#check (. + 2)
#eval twice (. + 2) 10

---

(module
  (interactive
    (parenthesized (binaryExpression (cdot) (number))))
  (interactive
    (parenthesized (binaryExpression (cdot) (number))))
  (interactive
    (apply
      (identifier)
      (parenthesized (binaryExpression (cdot) (number))) (number))))

=================
Explicit Function
=================

#check @ident
#check @ident Œ±
#check @ident Bool true
#check @foo.bar

---

(module
  (interactive (explicit (identifier)))
  (interactive (apply (explicit (identifier)) (identifier)))
  (interactive (apply (explicit (identifier)) (identifier) (true)))
  (interactive (explicit (identifier))))

===============
Type Ascription
===============

#check (2 : Nat)
#check (foo bar : Nat)
#check (foo bar : baz quux)

---

(module
  (interactive
    (parenthesized
      (number)
      (typeAscription
        type: (identifier))))
  (interactive
    (parenthesized
      (apply
        lhs: (identifier)
        argument: (identifier))
      (typeAscription
        type: (identifier))))
  (interactive
    (parenthesized
      (apply
        lhs: (identifier)
        argument: (identifier))
      (typeAscription
        type:
          (apply
            lhs: (identifier)
            argument: (identifier))))))

=================================
Application Across Multiple Lines
=================================

#eval f
2
3

  4

---

(module
  (interactive
    (apply
      lhs: (identifier)
      argument: (number)
      argument: (number)
      argument: (number))))

=================
Structure Literal
=================

#check {x := 12}
#check {x := 12, y := (fun z => z)}

---

(module
  (interactive
    (structureInstance
      name: (identifier)
      value: (number)))
  (interactive
    (structureInstance
      name: (identifier)
      value: (number)
      name: (identifier)
      value:
        (parenthesized
          (fun
            (parameters
              name: (identifier))
            (identifier))))))

=======================
Typed Structure Literal
=======================

#check {x := 12 : Foo}
#check {x := 12, y := (fun z => z) : Foo Bar}
#check {: Foo}

---

(module
  (interactive
    (structureInstance
      name: (identifier)
      value: (number)
      type: (identifier)))
  (interactive
    (structureInstance
      name: (identifier)
      value: (number)
      name: (identifier)
      value:
        (parenthesized
          (fun
            (parameters
              name: (identifier))
            (identifier)))
      type:
        (apply
          lhs: (identifier)
          argument: (identifier))))
  (interactive
    (structureInstance
      type: (identifier))))

====================
Structure Overriding
====================

#check {foo with x := 12}
#check {foo with x := 12, y := (fun z => z)}
#check {foo with}
#check {bar 37 with x := 12}

---

(module
  (interactive
    (structureInstance
      extends: (identifier)
      name: (identifier)
      value: (number)))
  (interactive
    (structureInstance
      extends: (identifier)
      name: (identifier)
      value: (number)
      name: (identifier)
      value:
        (parenthesized
          (fun
            (parameters
              name: (identifier))
            (identifier)))))
  (interactive
    (structureInstance
      extends: (identifier)))
  (interactive
    (structureInstance
      extends:
        (apply
          lhs: (identifier)
          argument: (number))
      name: (identifier)
      value: (number))))

===================
Trailing Commas Yay
===================

example : Foo := {x := 12, y := 13,}

---

(module
  (declaration
    (example (identifier)
      (structureInstance (identifier) (number) (identifier) (number)))))

=====================
No Trailing Commas Aw
=====================

#check (1, 2, 3,)
#check [1, 2, 3,]
#check #[1, 2, 3,]
example : Foo := ‚ü®1, 2,‚ü©
@[foo, bar,] def foo := 12
def foo | 0, => 2 | _, => 3

---

(module
  (interactive
    (parenthesized (number) (tupleTail (number) (number)) (ERROR)))
  (interactive
    (list (number) (number) (number) (identifier (MISSING _identifier))))
  (interactive
    (array (number) (number) (number) (identifier (MISSING _identifier))))
  (declaration
    (example (identifier)
      (anonymousConstructor
        (number) (number) (identifier (MISSING _identifier)))))
  (declaration
    (attributes (identifier) (identifier) (identifier (MISSING _identifier)))
    (def (identifier) (number)))
  (declaration
    (def (identifier)
      (matchAlt (number) (ERROR) (number))
      (matchAlt (hole) (ERROR) (number)))))

=====
Sorry
=====

#check sorry

---

(module (interactive (sorry)))

==================
Escaped Identifier
==================

def ¬´foo

bar


theorem baz : (afweio)¬ª := 12

---

(module
  (declaration
    (def
      name: (identifier)
      body: (number))))

======
Unless
======

#check (unless true do PUnit.unit : PUnit)

---

(module
  (interactive
    (parenthesized
      (unless (true)
        (do (identifier)))
      (typeAscription
        type: (identifier)))))

===========
Quantifiers
===========

#check ‚àÄ x, ‚àÉ y, x + y = x
#check ‚àÉ (x y : Nat), ‚àÄ w, w + x + y + z = x

---

(module
  (interactive
    (forall
      binders:
        (binders
          name: (identifier))
      body:
        (exists
          binders:
            (binders
              name: (identifier))
          body:
            (binaryExpression
              (binaryExpression (identifier) (identifier))
              (identifier)))))
  (interactive
    (exists
      binders:
        (binders
          (explicitBinder
            name: (identifier)
            name: (identifier)
            type: (identifier)))
      body:
        (forall
          binders:
            (binders
              name: (identifier))
          body:
            (binaryExpression
              (binaryExpression
                (binaryExpression
                  (binaryExpression (identifier) (identifier))
                  (identifier))
                (identifier))
              (identifier))))))

========
Borrowed
========

#check @& String

---

(module (interactive (borrowed (identifier))))

===========
Quoted Name
===========

#check `String

---

(module (interactive (quotedName (identifier))))

==================
Double Quoted Name
==================

#check ``String

---

(module (interactive (doubleQuotedName (identifier))))

===========
Lift Method
===========

#check ‚Üê Nat

---

; This will runtime error (must be nested inside a 'do' expression),
; but is valid syntax

(module (interactive (liftMethod (identifier))))

=======
Subtype
=======

#check {x // x > 2}

---

(module
  (interactive
    (subtype (identifier) (comparison (identifier) (number)))))

=================
Ellipsis Argument
=================

#check f ..

---

(module
  (interactive (apply (identifier) (ellipsis))))
